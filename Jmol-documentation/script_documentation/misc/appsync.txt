# new feature: The Jmol application can now communicate via sockets
#   with other Jmol applications or specialized servers. 
#   The SYNC command has been expanded to make this very easy: 
#
#     sync -nnnn   starts a server on local port nnnn accepting only local connections
#     sync nnnn "background white" (from another app, generally) would execute that 
#                                command on the app acting as a server
#
#   You can also do this from one app frame to another, because they are independent
#   instances of Jmol.
#
#   Jmol can provide server service to other apps using:
#
#   sync -3000
#   [start other app, connecting on 3000]
#   sync 3000 .....
#
#   Because once the server is started and another app has connected, 
#   Jmol will send messages to that other app, not itself. 
#   
#   To test the service within one application, just create the server and send 
#   commands to itself using a negative port number:
#
#   sync -3000;sync -3000 'Mouse: rotateZBy 30'
#
#   Note that in this context the "server" is the one getting commands from the "client"
#   But the server can also send commands to the client provided the client has given the
#   appropriate handshake: {"magic":"JmolApp","event":"out"}
#
# Sent from Jmol (via outSocket): 
# 
#   {"magic" : "JmolApp", "role" : "out"}  (socket initialization for messages TO jmol)
#   {"magic" : "JmolApp", "role" : "in"}   (socket initialization for messages FROM jmol)
#   {"type" : "script", "event" : "done"}  (script completed)
#   
# Sent to Jmol (via inSocket):
# 
#   {"type" : "banner", "mode" : "ON" or "OFF" }   (set banner for kiosk)
#   {"type" : "banner", "text" : bannerText }      (set banner for kiosk)
#   {"type" : "command", "command" : command }  (script command request)
#   {"type" : "content", "id" : id }            (load content request)
#   {"type" : "move", "style" : (see below) }   (mouse command request)
#   {"type" : "quit" }                          (shut down request)
#   {"type" : "sync", "sync" : (see below) }    (sync command request)
#   {"type" : "touch",                          (a raw touch event)
#        "eventType" : eventType,
#        "touchID"   : touchID,
#        "iData"     : idata,
#        "time"      : time,
#        "x" : x, "y" : y, "z" : z }
#    
#   For details on the "touch" type, see org.jmol.viewer.ActionManagerMT::processEvent
#   Content is assumed to be in a location determined by the Jmol variable
#   nioContentPath, with %ID% being replaced by some sort of ID number of tag provided by
#   the other half of the system. That file contains more JSON code:
#   
#   {"startup_script" : scriptFileName, "banner_text" : text } 
#   
#   An additional option "banner" : "off" turns off the title banner.
#   The startup script must be in the same directory as the .json file, typically as a .spt file
#   
#   Move/sync commands include:
#   
#   {"type" : "move", "style" : "rotate", "x" : deltaX, "y", deltaY }
#   {"type" : "move", "style" : "translate", "x" : deltaX, "y", deltaY }
#   {"type" : "move", "style" : "zoom", "scale" : scale }  (1.0 = 100%)
#   {"type" : "sync", "sync" : syncText }
#   
#   Note that all these moves utilize the Jmol sync functionality originally intended for
#   applets. So any valid sync command may be used with the "sync" style. These include 
#   essentially all the actions that a user can make with a mouse, including the
#   following, where the notation <....> represents a number of a given type. These
#   events interrupt any currently running script, just as with typical mouse actions.
#   
#   "centerAt <int:x> <int:y> <float:ptx> <float:pty> <float:ptz>"
#      -- set {ptx,pty,ptz} at screen (x,y)
#   "rotateMolecule <float:deltaX> <float:deltaY>"
#   "rotateXYBy <float:deltaX> <float:deltaY>"
#   "rotateZBy <int:degrees>"
#   "rotateZBy <int:degrees> <int:x> <int:y>" (with center reset)
#   "rotateArcBall <int:x> <int:y> <float:factor>"
#   "spinXYBy <int:x> <int:y> <float:speed>"
#      -- a "flick" gesture
#   "translateXYBy <float:deltaX, float:deltaY>"
#   "zoomBy <int:pixels>"
#   "zoomByFactor <float:factor>"
#   "zoomByFactor <float:factor> <int:x> <int:y>" (with center reset)
# 
