/* $RCSfile$
 * $Author$
 * $Date$
 * $Revision$
 *
 * Copyright (C) 2003-2004  The Chemistry Development Kit (CDK) project
 *
 * Contact: cdk-devel@lists.sourceforge.net
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1
 * of the License, or (at your option) any later version.
 * All we ask is that proper credit is given for our work, which includes
 * - but is not limited to - adding the above copyright notice to the beginning
 * of your source code files, and to any copyright notice that you may distribute
 * with programs based on this work.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */
package org.jmol.adapter.smarter;

import java.io.BufferedReader;
import java.util.StringTokenizer;


/**
 * This is not a reader for the CIF and mmCIF crystallographic formats.
 * It is able, however, to extract some content from it.
 * It's very ad hoc, not written
 * using any dictionary. So please complain if something is not working.
 * In addition, the things it does read are considered experimental.
 */
public class CifReader extends ModelReader {

  float[] notionalUnitcell;

  
  float a = Float.NaN;
  float b = Float.NaN;
  float c = Float.NaN;
  float alpha = Float.NaN;
  float beta = Float.NaN;
  float gamma = Float.NaN;
  
  /**
   * Create an CIF like file reader.
   *
   * @param input source of CIF data
   */
  Model readModel(BufferedReader reader, ModelAdapter.Logger logger)
    throws Exception {
    this.logger = logger;
    model = new Model(ModelAdapter.MODEL_TYPE_OTHER);
    
    boolean end_found = false;
    String line;
    while (!end_found && (line = reader.readLine()) != null) {
      if (line.length() == 0)
        continue;
      char firstChar = line.charAt(0);
      if (firstChar == '#')
        continue;
      if ((firstChar != '_') &&
          ! line.startsWith("loop")) {
        logger.log("skipping unrecognized line", line);
        continue;
      }
      /* determine CIF command */
      int spaceIndex = line.indexOf(' ');
      if (spaceIndex == -1)
        spaceIndex = line.length();
      String command = line.substring(0, spaceIndex);
      if (command.startsWith("_cell")) {
        processCellParameter(command, line, spaceIndex);
        continue;
      }
      if ("loop_".equals(command)) {
        processLoopBlock();
        continue;
      }
      if ("_symmetry_space_group_name_H-M".equals(command)) {
        String value = line.substring(29).trim();
        crystal.setSpaceGroup(value);
        continue;
      }
      // skip command
    }
    return model;
  }
  
  final static String[] cellParamNames =
  {"_cell.length_a", "_cell.length_b", "_cell.length_c",
   "_cell.angle_alpha", "_cell.angle_beta", "_cell.angle.gamma"};

  private void processCellParameter(String command,
                                    String line, int spaceIndex) {
    for (int i = cellParamNames.length; --i >= 0 )
      if (command.equals(cellParamNames[i])) {
        notionalUnitCell[i] = parseFloat(line, spaceIndex);
        return;
      }
  }
  
    private void processLoopBlock() throws IOException {
        String line = input.readLine().trim();
        if (line.startsWith("_atom")) {
            logger.info("Found atom loop block");
            processAtomLoopBlock(line);
        } else {
            logger.warn("Skipping loop block");
            skipUntilEmptyOrCommentLine(line);
        }
    }

    private void skipUntilEmptyOrCommentLine(String line) throws IOException {
        // skip everything until empty line, or comment line
        while (line != null && line.length() > 0 && line.charAt(0) != '#') {
            line = input.readLine().trim();
        }
    }
    
    private void processAtomLoopBlock(String firstLine) throws IOException {
        int atomLabel = -1; // -1 means not found in this block
        int atomSymbol = -1;
        int atomFractX = -1;
        int atomFractY = -1;
        int atomFractZ = -1;
        int atomRealX = -1;
        int atomRealY = -1;
        int atomRealZ = -1;
        String line = firstLine.trim();
        int headerCount = 0;
        boolean hasParsableInformation = false;
        while (line != null && line.charAt(0) == '_') {
            headerCount++;
            if (line.equals("_atom_site_label") ||
                line.equals("_atom_site_label_atom_id")) {
                atomLabel = headerCount;
                hasParsableInformation = true;
                logger.info("label found in col: " + atomLabel);
            } else if (line.startsWith("_atom_site_fract_x")) {
                atomFractX = headerCount;
                hasParsableInformation = true;
                logger.info("frac x found in col: " + atomFractX);
            } else if (line.startsWith("_atom_site_fract_y")) {
                atomFractY = headerCount;
                hasParsableInformation = true;
                logger.info("frac y found in col: " + atomFractY);
            } else if (line.startsWith("_atom_site_fract_z")) {
                atomFractZ = headerCount;
                hasParsableInformation = true;
                logger.info("frac z found in col: " + atomFractZ);
            } else if (line.equals("_atom_site.Cartn_x")) {
                atomRealX = headerCount;
                hasParsableInformation = true;
                logger.info("cart x found in col: " + atomRealX);
            } else if (line.equals("_atom_site.Cartn_y")) {
                atomRealY = headerCount;
                hasParsableInformation = true;
                logger.info("cart y found in col: " + atomRealY);
            } else if (line.equals("_atom_site.Cartn_z")) {
                atomRealZ = headerCount;
                hasParsableInformation = true;
                logger.info("cart z found in col: " + atomRealZ);
            } else if (line.equals("_atom_site.type_symbol")) {
                atomSymbol = headerCount;
                hasParsableInformation = true;
                logger.info("type_symbol found in col: " + atomSymbol);
            } else {
                logger.warn("Ignoring atom loop block field: " + line);
            }
            line = input.readLine().trim();
        }
        if (hasParsableInformation == false ) {
            logger.info("No parsable info found");
            skipUntilEmptyOrCommentLine(line);
        } else {
            // now that headers are parsed, read the data
            while(line != null && line.length() > 0 && line.charAt(0) != '#') {
                logger.debug("new row");
                StringTokenizer tokenizer = new StringTokenizer(line);
                if (tokenizer.countTokens() < headerCount) {
                    logger.warn("Column count mismatch; assuming continued on next line");
                    logger.debug("Found #expected, #found: " + headerCount + ", " + tokenizer.countTokens());
                    tokenizer = new StringTokenizer(line + input.readLine());
                }
                int colIndex = 0;
                // process one row
                Atom atom = new Atom("C");
                double[] frac = new double[3];
                double[] real = new double[3];
                boolean hasFractional = false;
                boolean hasCartesian = false;
                while (tokenizer.hasMoreTokens()) {
                    colIndex++;
                    String field = tokenizer.nextToken();
                    logger.debug("Parsing col,token: " + colIndex + "=" + field);
                    if (colIndex == atomLabel) {
                        if (atomSymbol == -1) {
                            // no atom symbol found, use label
                            String element = extractFirstLetters(field);
                            atom.setSymbol(element);
                        }
                        atom.setID(field);
                    } else if (colIndex == atomFractX) {
                        hasFractional = true;
                        frac[0] = parseIntoDouble(field);
                    } else if (colIndex == atomFractY) {
                        hasFractional = true;
                        frac[1] = parseIntoDouble(field);
                    } else if (colIndex == atomFractZ) {
                        hasFractional = true;
                        frac[2] = parseIntoDouble(field);
                    } else if (colIndex == atomSymbol) {
                        atom.setSymbol(field);
                    } else if (colIndex == atomRealX) {
                        hasCartesian = true;
                        logger.debug("Adding x3: " + parseIntoDouble(field));
                        real[0] = parseIntoDouble(field);
                    } else if (colIndex == atomRealY) {
                        hasCartesian = true;
                        logger.debug("Adding y3: " + parseIntoDouble(field));
                        real[1] = parseIntoDouble(field);
                    } else if (colIndex == atomRealZ) {
                        hasCartesian = true;
                        logger.debug("Adding x3: " + parseIntoDouble(field));
                        real[2] = parseIntoDouble(field);
                    }
                }
                if (hasCartesian) {
                    double[] a = crystal.getA();
                    double[] b = crystal.getB();
                    double[] c = crystal.getC();
                    frac = CrystalGeometryTools.cartesianToFractional(a, b, c, real);
                    atom.setFractionalPoint3D(new Point3d(frac[0], frac[1], frac[2]));
                }
                if (hasFractional) {
                    atom.setFractionalPoint3D(new Point3d(frac[0], frac[1], frac[2]));
                }
                logger.debug("Adding atom: " + atom);
                crystal.addAtom(atom);
                
                // look up next row
                line = input.readLine().trim();
            }
        }
    }
    
    /**
     * Process double in the format: '.071(1)'.
     */
    private double parseIntoDouble(String value) {
        double returnVal = 0.0;
        if (value.charAt(0) == '.') value = "0" + value;
        int bracketIndex = value.indexOf("(");
        if (bracketIndex != -1) {
            value = value.substring(0, bracketIndex);
        }
        try {
            returnVal = Double.parseDouble(value);
        } catch (Exception exception) {
            logger.error("Could not parse double string: " + value);
        }
        return returnVal;
    }

  private float parseFloat(String line, int startIndex) {
    float value = 0;
    int ich = startIndex;
    int cch = line.length();
    char ch;
    while (cch < line.length && (ch = line.charAt(ich)) == ' ')
      ++ich;
  }
    
    private String extractFirstLetters(String value) {
        StringBuffer result = new StringBuffer();
        for (int i=0; i<value.length(); i++) {
            if (Character.isDigit(value.charAt(i))) {
                break;
            } else {
                result.append(value.charAt(i));
            }
        }
        return result.toString();
    }
    
    public void close() throws IOException {
        input.close();
    }
}
